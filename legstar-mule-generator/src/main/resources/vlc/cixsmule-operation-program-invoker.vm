##/////////////////////////////////////////////////////////////////////
##Jaxws Operation Invoker Template.
##@author Fady
##@version 1.2.3
##/////////////////////////////////////////////////////////////////////
## ==================================================================
#macro(getTransformersTypes $cixsStructures)
##
## Transformer Providers need to be imported
##
#foreach ($cixsStructure in $cixsStructures)
#set($transfomerProvider = ${cixsStructure.jaxbType} + "Transformers")
#set($newType = ${helper.getQualClassName(${cixsStructure.coxbPackageName}, ${transfomerProvider})})
#addUnique($importTypes $newType)
#end
#end
## ==================================================================
#parse("vlc/j2c-service-common-imports.vm")
## ==================================================================
## Create unique Lists of imports and Types
##
#set($importTypes = [])
#set($jaxbTypes = [])
#getImportTypes(${cixsOperation.getInput()})
#getImportTypes(${cixsOperation.getOutput()})
#getTransformersTypes(${cixsOperation.getInput()})
#getTransformersTypes(${cixsOperation.getOutput()})
## ==================================================================
#if(${cixsOperation.packageName})
package ${cixsOperation.packageName};
#end
import com.legstar.coxb.transform.HostTransformException;
import com.legstar.host.invoke.AbstractProgramInvoker;
import com.legstar.host.invoke.HostInvoker;
import com.legstar.host.invoke.HostInvokerException;
import com.legstar.messaging.LegStarAddress;
#if($cixsOperation.hasChannel())
import java.util.LinkedHashMap;
import java.util.Map;
#end
#foreach($importType in $importTypes)
import ${importType};
#end

/**
 * Implements an invoker for program ${cixsOperation.cicsProgramName}.
 * <p/>
 * This host program maps to operation ${cixsOperation.name}.
 * 
 * This class was generated by ${generatorName}.
 *
 */
public class ${cixsOperation.className}ProgramInvoker extends AbstractProgramInvoker {

#foreach($jaxbType in $jaxbTypes)
    /** Host transformers for ${jaxbType} java data object. */
    private ${jaxbType}Transformers m${jaxbType}Transformers;
#end

    /** Operation name for ${cixsOperation.name}. */
    private static final String  OPERATION_NAME = "${cixsOperation.name}";

    /** Properties for operation ${cixsOperation.name}. */
    private static final String  PROGRAM_PROPERTIES = "${cixsOperation.cicsProgramName.toLowerCase()}.properties";

    /**
     * Operation invoker constructor.
     * @param configFileName invoker configuration file name
     */
    public ${cixsOperation.className}ProgramInvoker(final String configFileName) {
        super(configFileName, OPERATION_NAME, PROGRAM_PROPERTIES);
#foreach($jaxbType in $jaxbTypes)
        m${jaxbType}Transformers = new ${jaxbType}Transformers();
#end
    }

    /**
     * Invoke the ${cixsOperation.cicsProgramName} host program.
     * <p/>
     * The sequence of operations performed is:
     * <ul>
     * <li>Get an invoker for the target host address and program</li>
     * <li>Transform request data object into host bytes</li>
     * <li>Invoke the remote program</li>
     * <li>Transform reply bytes into java data object</li>
     * </ul>
     * @param address target host address
     * @param requestID a unique identifier for this request
     * @param request the request java data object 
     * @return the reply java data object
     * @throws HostInvokerException if host invoker cannot be created or configured
     * @throws HostTransformException if transformation fails
     */
    public final $cixsOperation.responseHolderType ${cixsOperation.name}(
            final LegStarAddress address,
            final String requestID,
            final $cixsOperation.requestHolderType request)
    throws HostInvokerException, HostTransformException {

        HostInvoker hostInvoker = getHostInvoker(address);
        String hostCharset = hostInvoker.getAddress().getHostCharset();

#if($cixsOperation.hasChannel())
## ------------------------------------------------------------------
## Container driven program
##
## ------------------------------------------------------------------
        Map < String, byte[] > requestParts =
            new LinkedHashMap < String, byte[] >(); 
#foreach ($cixsStructure in $cixsOperation.getInput())
        requestParts.put("${cixsStructure.cicsContainer}",
             get${cixsStructure.jaxbType}Transformers().toHost(
                request.get${cixsStructure.jaxbPropertyName}(), hostCharset));
#end

        Map < String, byte[] > replyParts =
            hostInvoker.invoke(requestID, requestParts);
        
        $cixsOperation.responseHolderType reply = new ${cixsOperation.responseHolderType}();
#foreach ($cixsStructure in $cixsOperation.getOutput())
        reply.set${cixsStructure.jaxbPropertyName}(
            get${cixsStructure.jaxbType}Transformers().toJava(
                replyParts.get("${cixsStructure.cicsContainer}"), hostCharset));
#end
        return reply;
#else
## ------------------------------------------------------------------
## Commarea driven program
##
#if (${cixsOperation.getInput().size()} > 0)
        byte[] requestBytes =
            get${cixsOperation.getInput().get(0).jaxbType}Transformers().toHost(request, hostCharset);

        byte[] replyBytes = hostInvoker.invoke(requestID, requestBytes);

#else
        byte[] replyBytes = hostInvoker.invoke(requestID, null);

#end
#if (${cixsOperation.getOutput().size()} > 0)
        return get${cixsOperation.getOutput().get(0).jaxbType}Transformers().toJava(replyBytes, hostCharset);
#else
        return null;
#end
#end
## ------------------------------------------------------------------

    }

#foreach($jaxbType in $jaxbTypes)
    /**
     * @return the host transformers for ${jaxbType}
     */
    public ${jaxbType}Transformers get${jaxbType}Transformers() {
        return m${jaxbType}Transformers;
    }

    /**
     * @param transformers the host transformers for ${jaxbType}
     */
    public void set${jaxbType}Transformers(
            final ${jaxbType}Transformers transformers) {
        m${jaxbType}Transformers = transformers;
    }

#end
}
