h1. QuickStart ESB proxy for a CICS program, using HTTP and ant scripts.

h2. QuickStart description

The purpose of this quickstart document is to quickly build a functioning sample integrating a backend IBM CICS system with a Mule component.

Once deployed, the generated ESB component will act as a proxy for a CICS COBOL program. In this example, the COBOL program acts as a client and the proxy ESB component invokes a POJO (plain old java object) method on behalf of the COBOL client.

!Legs4Mule-quickstart-proxy-http.png!

h2. Installation

Follow instructions in:[InstallationInstructions]

The src/com/legstar/xsdc/test/cases/jvmquery folder contains a sample POJO called *JVMQuery.java*. As the name implies, JVMQuery queries a JVM for system variables such as environment variables and locale. A caller can specify an array of environment variables for which values should be queried. If you look at the *queryJvm* method, you will notice that it takes a single data object called *JVMQueryRequest* as input and produces a data object called *JVMQueryReply*.

This example uses HTTP connectivity from CICS to Mule using the LegStar Mule transport.
 
h2. Generate a Mule component proxy for a mainframe program

These steps will guide you through the process of generating an ESB proxy using ant scripts. There is an alternative method, using Eclipse plugins, that will be described later.

We will be generating all the artifacts that are needed to give a CICS COBOL program the ability to call the *queryJvm* method or JVMQuery.

First step is to generate an XML schema from the target Java data objects *JVMQueryRequest* and *JVMQueryReply*.

Go to folder samples/mule/quickstarts/legstar_proxy.

From the ant folder, run command *ant -f build-pojo.xml*, this will compile the target POJO.

From the ant folder, run command *ant -f build-java2xs.xml*. This should create a schema folder with a generated XML schema jvmquery.xsd.

If you open jvmquery.xsd you will notice that each Java data object has been mapped to a COBOL data structure as well as an XML Schema type.

Next step turns the XML schema types into Java annotated classes. This is achieved with 3 ant scripts *build-jaxb.xml*, *build-coxb-jvmqueryrequest.xml* and *build-coxb-jvmqueryreply.xml*:

 * Run command *ant -f build-jaxb.xml*. As a result, the src folder contains generated JAXB classes. These were derived from the generated XML Schema in the schema folder. Sources are also compiled, with binaries stored under build.

 * Run command *ant -f build-coxb-jvmqueryrequest.xml*, then *ant -f build-coxb-jvmqueryreply.xml*. This should create binding classes which can be used as an alternative to the JAXB classes to achieve high performances.

The last step generates the queryJvmLocalUMO Mule component.

From the ant folder run command *ant -f build-cixs2mule.xml*. 

Under src/com/legstar/test/cixs/mule/jvmquery you will find a set of generated transformers such as *HostByteArrayToJvmQueryRequest.java* or *JvmQueryReplyToHostByteArray.java*. These are generated Mule transformers which are in charge of marshaling/unmarshaling the mainframe data into java data objects.

Under legstar_proxy, Mule configuration samples are generated:

 * mule-proxy-config-jvmquery.xml

 Is the Mule component descriptor. This sample component implements a sequence of 3 actions in a Request/Response exchange pattern. The first action marshals the mainframe request data into a *JvmQueryRequest* java data object. The second one invokes the *queryJvm* method of the POJO using the standard Mule capabilities. Finally the third one unmarshals the *JvmQueryReply* java data object into a mainframe reply.

 Check the HTTP listening host and port number in mule-proxy-config-jvmquery.xml to see if they fit your needs.

The ant folder contains the build.xml generated ant script which bundles the mule-legstar-jvmquery.jar file and deploys the generated component to your Mule installation (Defined by the MULE_HOME environment variable).

h2. Running the ESB component proxy

The *cobol* folder contains a generated skeleton COBOL CICS program that you can use to test the ESB proxy. Edit this code and perform the following changes:

 * Change the W00-SERVICE-URI size and value to point to the server running Mule.
 * Right after the "TODO set input values in COM-REQUEST" comment, insert these lines of code:

{code}
           MOVE 2 TO envVarNames--C OF COM-REQUEST.           
           MOVE 'MULE_HOME' TO envVarNames OF COM-REQUEST(1). 
           MOVE 'JAVA_HOME' TO envVarNames OF COM-REQUEST(2).
{code}
 * Right after the "TODO do something useful with data returned in COM-REPLY" comment, insert these lines of code:

{code}
           STRING 'INVOKE-SERVICE success. Server language is '     
                  DELIMITED BY SIZE                                 
                  language OF COM-REPLY                             
                  DELIMITED BY SPACE                                
                  INTO ERROR-MESSAGE.                               
           EXEC CICS SEND TEXT FROM(ERROR-MESSAGE) FREEKB END-EXEC. 
                                                                    
           DISPLAY 'country=' country OF COM-REPLY.                 
           DISPLAY 'currencySymbol=' currencySymbol OF COM-REPLY.   
           DISPLAY 'formattedDate=' formattedDate OF COM-REPLY.     
           DISPLAY 'language=' language OF COM-REPLY.               
           DISPLAY 'envVarValues--C=' envVarValues--C OF COM-REPLY. 
           DISPLAY 'envVarValues(1)=' envVarValues OF COM-REPLY (1).
           DISPLAY 'envVarValues(2)=' envVarValues OF COM-REPLY (2).
{code}
You should now be able to upload this program onto your mainframe and get it compiled and defined to your CICS region. Please note that this program calls the CICS DFHWBCLI program defined in the CICS standard DFHWEB group. Alternatively, legstar-mule supports the new EXEC CICS WEB API or even supports older version of CICS with its own HTTP library.

If you associate the JVMQUERY program to a CICS transaction and run that transaction, it should return with a short message telling you which locale
the Mule server is actually using. The standard CICS/LE CEEMSG and CEEOUT should show detailed traces.
